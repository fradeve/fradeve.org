---
title: Bin 2D uneven data
description: >
    Binning irregularly spaced data on independent rectangular cells.
created: !!timestamp '2010-11-06 10:00:00'
---

{% mark image -%}
{%- endmark %}

Here is a very simple method to compute median (or mean) values on rectangular bins using **only** the data withing the particular bin in question, and performing no estimation if no data is available.

Source code
-----------

* ``bindata.py`` - Simple module for binning irregularly spaced data 
  on independent rectangular cells (regular grid).

Get the code on [GitHub](https://github.com/fspaolo/code/tree/master/bindata).

Example
-------

Function for binning data using rectangular cells:

    :::python 

    import numpy as np
    import matplotlib.pyplot as plt
    import matplotlib.cm as cm
    import sys
    
    def bindata(x, y, z, xi, yi, ppbin=False, binval='median'):
        """
        Bin irregularly spaced data on a regular grid (center of the bins).
     
        Computes the median (default) or mean value within bins defined by
        regularly spaced xi and yi coordinates (the grid defining the bins).
        
        Parameters
        ----------
        x, y : ndarray (1D)
            The idependent variables x- and y-axis of the grid.
        z : ndarray (1D)
            The dependent variable in the form z = f(x,y).
        xi, yi : ndarray (1D)
            The coordinates defining the x- and y-axis of the grid.
        ppbin : boolean, optional
            The function returns `bins` variable (see below for description): 
            [False | True].
        binval : string, optional
            The statistical operator used to compute the value of each 
            bin: ['median' | 'mean'].
       
        Returns
        -------
        grid : ndarray (2D)
            The evenly binned data. The value of each cell is the median
            (or mean) value of the contents of the bin.
        bins : ndarray (2D)
            A grid the same shape as `grid`, except the value of each cell
            is the number of points per bin. Returns only if `ppbin` is set
            to True.
     
        Revisions
        ---------
        2010-11-06 Fernando Paolo, Initial version 
        """
     
        if binval == 'median':
            median = True
        else:
            median = False
     
        # make the grid
        nrow = yi.shape[0]
        ncol = xi.shape[0]
        grid = np.empty((nrow,ncol), dtype=xi.dtype)
        if ppbin: bins = np.copy(grid)
     
        # step size (rectangular cells)
        dx = xi[1]-xi[0]
        dy = yi[1]-yi[0]
        hx = dx/2.
        hy = dy/2.
     
        # bin the data
        for row in xrange(nrow):
            for col in xrange(ncol):
                xc = xi[col]          # xc,yc = center of the bin
                yc = yi[row]
                ind, = np.where((xc-hx <= x) & (x < xc+hx) & \
                                (yc-hy <= y) & (y < yc+hy))
                npts = len(ind)
                if npts > 0:
                    if median:
                        grid[row,col] = np.median(z[ind])
                    else:
                        grid[row,col] = np.mean(z[ind])
                    if ppbin: bins[row,col] = npts
                else:
                    grid[row,col] = np.nan
                    if ppbin: bins[row,col] = 0
     
        # return the grid
        if ppbin:
            return grid, bins
        else:
            return grid

Using the above function we can compare the binning process against other interpolation method, e.g., [natural neighbor](http://en.wikipedia.org/wiki/Natural_neighbor). So place the file ``bindata.py`` in the same directory as the following script:

    :::python

    import numpy as np
    import numpy.ma as ma
    from numpy.random import uniform
    from matplotlib.mlab import griddata
    import matplotlib.pyplot as plt
    
    from bindata import bindata, plotbins  # the bindata.py module
    
    # make up some randomly distributed data
    npts = 700
    x = uniform(-2, 2, npts)
    y = uniform(-2, 2, npts)
    z = x*np.exp(-x**2-y**2)
    
    # define the grid
    xi = np.linspace(-2.1, 2.1, 20)
    yi = np.linspace(-2.1, 2.1, 20)
    
    # grid the data.
    zi = griddata(x, y, z, xi, yi)
    
    # plot the data
    plt.figure()
    plotbins(xi, yi, zi)
    plt.colorbar()
    plt.scatter(x, y, marker='o', c='b', s=3)
    plt.xlim(xi.min(), xi.max())
    plt.ylim(yi.min(), yi.max())
    plt.title('Gridded data (%d points)' % npts)

    # bin the data.
    zi = bindata(x, y, z, xi, yi)
    
    # plot the data
    plt.figure()
    plotbins(xi, yi, zi)
    plt.colorbar()
    plt.scatter(x, y, marker='o', c='b', s=3)
    plt.xlim(xi.min(), xi.max())
    plt.ylim(yi.min(), yi.max())
    plt.title('Binned data (%d points)' % npts)
    
    plt.show()

And we get the following images. Note the empty cells where no data (black dots) are available:

![Binned data]([[!!images/binned-data.png]])
![Gridded data]([[!!images/gridded-data.png]])
